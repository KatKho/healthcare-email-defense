<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Healthcare Email Defense Agent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c5aa0 0%, #1e3a8a 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .input-section {
            background: #f8fafc;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid #e2e8f0;
        }

        .input-section h2 {
            color: #2d3748;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #2c5aa0;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        .analyze-btn {
            background: linear-gradient(135deg, #2c5aa0 0%, #1e3a8a 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(44, 90, 160, 0.3);
        }

        .analyze-btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .example-btn {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .example-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(56, 161, 105, 0.3);
        }

        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2c5aa0;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results-section {
            margin-top: 30px;
        }

        .results-section h2 {
            color: #2d3748;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .results-table th {
            background: #f7fafc;
            color: #4a5568;
            font-weight: 600;
            padding: 15px;
            text-align: left;
            border-bottom: 2px solid #e2e8f0;
        }

        .results-table td {
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
            vertical-align: top;
        }

        .results-table tr:hover {
            background: #f8fafc;
        }

        .classification {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .classification.safe {
            background: #c6f6d5;
            color: #22543d;
        }

        .classification.suspicious {
            background: #fef5e7;
            color: #744210;
        }

        .classification.phishing {
            background: #fed7d7;
            color: #742a2a;
        }

        .confidence {
            font-weight: 600;
            color: #2d3748;
        }

        .ai-comment {
            font-style: italic;
            color: #718096;
            max-width: 300px;
        }

        .feedback-section {
            margin-top: 10px;
        }

        .review-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
            width: 100%;
        }

        .review-btn:hover {
            background: #5a67d8;
        }


        .feedback-buttons {
            display: flex;
            gap: 10px;
        }

        .feedback-btn {
            padding: 6px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .feedback-btn.correct {
            border-color: #38a169;
            color: #38a169;
        }

        .feedback-btn.correct:hover {
            background: #38a169;
            color: white;
        }

        .feedback-btn.incorrect {
            border-color: #e53e3e;
            color: #e53e3e;
        }

        .feedback-btn.incorrect:hover {
            background: #e53e3e;
            color: white;
        }

        .feedback-btn.selected {
            color: white;
        }

        .feedback-btn.selected.correct {
            background: #38a169;
            border-color: #38a169;
        }

        .feedback-btn.selected.incorrect {
            background: #e53e3e;
            border-color: #e53e3e;
        }

        .no-results {
            text-align: center;
            color: #718096;
            font-style: italic;
            padding: 40px;
        }

        .agent-status {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .agent-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .agent-status h3 {
            margin: 0;
            font-size: 1.2rem;
        }

        .refresh-stats-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .refresh-stats-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }

        .agent-controls {
            display: flex;
            gap: 8px;
        }

        .clear-history-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .clear-history-btn:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
            transform: scale(1.05);
        }


        .last-updated {
            text-align: center;
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 10px;
            font-style: italic;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }

        .status-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .status-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .agent-actions {
            margin-top: 8px;
        }

        .agent-action {
            display: inline-block;
            background: #fef5e7;
            color: #744210;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-right: 5px;
            margin-bottom: 3px;
        }

        .agent-action.quarantine {
            background: #fed7d7;
            color: #742a2a;
        }

        .agent-action.escalate {
            background: #fef5e7;
            color: #744210;
        }

        .agent-action.pattern_based {
            background: #c6f6d5;
            color: #22543d;
        }

        .learning-indicator {
            color: #38a169;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .security-details {
            margin-top: 5px;
            padding: 5px;
            background: #f7fafc;
            border-radius: 4px;
            border-left: 3px solid #e53e3e;
        }

        .security-details small {
            color: #4a5568;
            font-size: 0.8rem;
        }

        .role-warning {
            margin-top: 5px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .role-warning.high {
            background: #fed7d7;
            border-left: 3px solid #e53e3e;
            color: #742a2a;
        }

        .role-warning.moderate {
            background: #fef5e7;
            border-left: 3px solid #d69e2e;
            color: #744210;
        }

        .role-info {
            margin-top: 5px;
            padding: 4px;
            background: #f0fff4;
            border-radius: 4px;
            border-left: 3px solid #38a169;
        }

        .role-info small {
            color: #2f855a;
            font-size: 0.8rem;
        }

        .reasoning-report-btn {
            background: linear-gradient(135deg, #2c5aa0 0%, #1e3a8a 100%);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.3s ease;
        }

        .reasoning-report-btn:hover {
            background: linear-gradient(135deg, #1e3a8a 0%, #1a365d 100%);
            transform: translateY(-1px);
        }

        .reasoning-report-btn:hover {
            background: linear-gradient(135deg, #1e3a8a 0%, #1a365d 100%);
            transform: translateY(-1px);
        }

        .reasoning-modal-content {
            max-width: 900px;
            width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
        }

        .reasoning-report-modal {
            font-size: 0.95rem;
        }

        .email-context {
            background: #f0f9ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #2c5aa0;
        }

        .email-context h3 {
            margin: 0 0 12px 0;
            color: #1e3a8a;
            font-size: 1.1rem;
        }

        .context-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.9rem;
        }

        .context-grid div {
            color: #374151;
        }

        .recipient-details-modal {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #bfdbfe;
        }

        .recipient-details-modal h4 {
            margin: 0 0 10px 0;
            color: #1e40af;
            font-size: 1rem;
        }

        .no-threats {
            color: #059669;
            font-style: italic;
        }

        .reasoning-section {
            margin-bottom: 15px;
        }

        .reasoning-section:last-child {
            margin-bottom: 0;
        }

        .reasoning-section h4 {
            color: #2d3748;
            font-size: 1rem;
            margin-bottom: 8px;
            border-bottom: 2px solid #2c5aa0;
            padding-bottom: 4px;
        }

        .reasoning-section p {
            color: #4a5568;
            line-height: 1.5;
            margin: 0;
        }

        .reasoning-section ul {
            color: #4a5568;
            margin: 0;
            padding-left: 20px;
        }

        .reasoning-section li {
            margin-bottom: 4px;
            line-height: 1.4;
        }

        .brief-comment {
            font-weight: 500;
            color: #2d3748;
        }

        .reasoning-section.recommendation {
            background: linear-gradient(135deg, #fef5e7 0%, #fed7d7 100%);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #d69e2e;
            margin-top: 20px;
        }

        .reasoning-section.recommendation h4 {
            color: #744210;
            border-bottom-color: #d69e2e;
        }

        .reasoning-section.recommendation p {
            color: #744210;
            font-size: 1rem;
        }

        .recipient-info {
            margin-top: 8px;
            padding: 10px;
            background: #f0f9ff;
            border-radius: 6px;
            border: 1px solid #bfdbfe;
        }

        .recipient-details {
            font-size: 0.9rem;
            color: #1e40af;
            font-weight: 500;
        }

        .unknown-user-warning {
            display: block;
            margin-top: 5px;
            color: #d69e2e;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .history-section {
            margin-top: 30px;
        }

        .history-section h2 {
            color: #2d3748;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .history-table {
            font-size: 14px;
        }

        .history-table th,
        .history-table td {
            padding: 12px 8px;
        }

        .history-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .history-status.auto_safe {
            background: #c6f6d5;
            color: #22543d;
        }

        .history-status.auto_learned {
            background: #e6fffa;
            color: #234e52;
        }

        .history-status.reviewed {
            background: #bee3f8;
            color: #2a69ac;
        }

        .moved-time {
            font-size: 12px;
            color: #718096;
            font-style: italic;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            background: linear-gradient(135deg, #2c5aa0 0%, #1e3a8a 100%);
            color: white;
            padding: 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .close {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            opacity: 0.7;
        }

        .modal-body {
            padding: 25px;
        }

        .email-details {
            margin-bottom: 25px;
        }

        .email-field {
            margin-bottom: 15px;
        }

        .field-label {
            font-weight: 600;
            color: #4a5568;
            display: block;
            margin-bottom: 5px;
        }

        .email-value {
            background: #f7fafc;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            word-break: break-all;
        }

        .email-body {
            background: #f7fafc;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            max-height: 300px;
            overflow-y: auto;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .analysis-details {
            margin-bottom: 25px;
        }

        .analysis-details h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .analysis-item {
            background: #f8fafc;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .analysis-item .field-label {
            font-weight: 600;
            color: #4a5568;
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .analysis-item span {
            color: #2d3748;
            font-size: 0.95rem;
        }

        .modal-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #e2e8f0;
        }

        .modal-close-btn {
            background: #718096;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .modal-close-btn:hover {
            background: #4a5568;
        }



        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 8px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .main-content {
                padding: 20px;
            }

            .results-table {
                font-size: 14px;
            }

            .results-table th,
            .results-table td {
                padding: 10px 8px;
            }

            .ai-comment {
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè• Healthcare Email Defense Agent</h1>
            <p>AI-Powered Email Security Analysis for Healthcare Organizations</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <h2>üìß Email Analysis</h2>
                
                <div class="form-group">
                    <label for="recipientEmail">Recipient Email:</label>
                    <input type="text" id="recipientEmail" placeholder="e.g., dr.smith@generalhospital.org" 
                           oninput="updateRecipientInfo()" style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
                    <div id="recipientInfo" class="recipient-info" style="display: none;">
                        <div class="recipient-details">
                            <span id="recipientName"></span> ‚Ä¢ 
                            <span id="recipientRole"></span> ‚Ä¢ 
                            <span id="recipientDepartment"></span>
                            <span id="unknownUserWarning" class="unknown-user-warning" style="display: none;">
                                ‚ö†Ô∏è Unknown user - role inferred from email pattern
                            </span>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="sender">Sender Email:</label>
                    <input type="text" id="sender" placeholder="e.g., admin@hospital.com">
                </div>

                <div class="form-group">
                    <label for="subject">Subject:</label>
                    <input type="text" id="subject" placeholder="Email subject line">
                </div>

                <div class="form-group">
                    <label for="body">Email Body:</label>
                    <textarea id="body" placeholder="Paste the email content here..."></textarea>
                </div>

                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="analyze-btn" onclick="analyzeEmail()">üîç Analyze Email</button>
                    <button class="example-btn" onclick="generateExample()">üé≤ Generate Example</button>
                </div>
                
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Analyzing email with AI...</p>
                </div>
            </div>

            <div class="results-section">
                <h2>üìä Analysis Results</h2>
                <div id="results-container">
                    <div class="no-results">
                        No emails analyzed yet. Submit an email above to see results.
                    </div>
                </div>
            </div>

            <div class="history-section">
                <h2>üìã History Log</h2>
                <div id="history-container">
                    <div class="no-results">
                        No emails in history yet. Reviewed emails and safe emails will appear here.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Email Review Modal -->
    <div id="emailModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìß Email Review</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="email-details">
                    <div class="email-field">
                        <div class="field-label">From:</div>
                        <div class="email-value" id="modalSender"></div>
                    </div>
                    <div class="email-field">
                        <div class="field-label">Subject:</div>
                        <div class="email-value" id="modalSubject"></div>
                    </div>
                    <div class="email-field">
                        <div class="field-label">Body:</div>
                        <div class="email-body" id="modalBody"></div>
                    </div>
                </div>
                
                <div class="analysis-details">
                    <h3>üîç AI Analysis</h3>
                    <div class="analysis-grid">
                        <div class="analysis-item">
                            <div class="field-label">Classification:</div>
                            <span id="modalClassification"></span>
                        </div>
                        <div class="analysis-item">
                            <div class="field-label">Confidence:</div>
                            <span id="modalConfidence"></span>
                        </div>
                        <div class="analysis-item">
                            <div class="field-label">Threat Score:</div>
                            <span id="modalThreatScore"></span>
                        </div>
                        <div class="analysis-item">
                            <div class="field-label">AI Comment:</div>
                            <span id="modalComment"></span>
                        </div>
                    </div>
                </div>

                <div class="modal-actions">
                    <button class="feedback-btn correct" onclick="confirmFeedbackFromModal('correct')">
                        üõ°Ô∏è Quarantine
                    </button>
                    <button class="feedback-btn incorrect" onclick="confirmFeedbackFromModal('incorrect')">
                        üìß Send Email
                    </button>
                    <button class="modal-close-btn" onclick="closeModal()">
                        Close
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Reasoning Report Modal -->
    <div id="reasoningModal" class="modal" style="display: none;">
        <div class="modal-content reasoning-modal-content">
            <div class="modal-header">
                <h2>üìä Detailed Reasoning Report</h2>
                <span class="close" onclick="closeReasoningModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="reasoningModalContent">
                    <!-- Content will be dynamically populated -->
                </div>
            </div>
            <div class="modal-actions">
                <button class="modal-close-btn" onclick="closeReasoningModal()">
                    Close Report
                </button>
            </div>
        </div>
    </div>

    <script>
        let analysisResults = [];
        let historyResults = [];
        let openrouterApiKey = '';
        let generationCounter = 0;
        let lastGeneratedType = null;
        
        // Agentic capabilities - persistent memory and learning
        let agentMemory = {
            learnedPatterns: {},
            feedbackHistory: [],
            threatIntelligence: {},
            rolePatterns: {
                // Store role-specific pattern learning
                // Structure: role -> pattern -> { count, classification, lastSeen }
            },
            performanceMetrics: {
                totalAnalyzed: 0,
                correctPredictions: 0,
                accuracyRate: 0,
                phishingCaught: 0,
                falsePositives: 0,
                securityThreatsBlocked: 0,
                highThreatEmails: 0,
                roleMismatches: 0
            },
            autoActions: {
                quarantineThreshold: 85,
                escalationThreshold: 90,
                autoQuarantineEnabled: true
            }
        };

        // Internal User Directory - Maps email addresses to roles
        const userDirectory = {
            // Medical Staff
            'dr.smith@generalhospital.org': { role: 'doctor', name: 'Dr. Sarah Smith', department: 'Cardiology' },
            'dr.johnson@generalhospital.org': { role: 'doctor', name: 'Dr. Michael Johnson', department: 'Emergency Medicine' },
            'dr.patel@generalhospital.org': { role: 'doctor', name: 'Dr. Priya Patel', department: 'Pediatrics' },
            'dr.chen@generalhospital.org': { role: 'doctor', name: 'Dr. Lisa Chen', department: 'Surgery' },
            
            // Nursing Staff
            'nurse.williams@generalhospital.org': { role: 'nurse', name: 'Rebecca Williams, RN', department: 'ICU' },
            'nurse.davis@generalhospital.org': { role: 'nurse', name: 'James Davis, RN', department: 'Emergency' },
            'nurse.garcia@generalhospital.org': { role: 'nurse', name: 'Maria Garcia, RN', department: 'Pediatrics' },
            'nurse.brown@generalhospital.org': { role: 'nurse', name: 'Ashley Brown, RN', department: 'Surgery' },
            'charge.nurse@generalhospital.org': { role: 'nurse', name: 'Patricia Martinez, RN', department: 'Charge Nurse' },
            
            // Administrative Staff
            'admin.thompson@generalhospital.org': { role: 'admin', name: 'Robert Thompson', department: 'Hospital Administration' },
            'admin.wilson@generalhospital.org': { role: 'admin', name: 'Jennifer Wilson', department: 'Patient Services' },
            'hr@generalhospital.org': { role: 'admin', name: 'HR Department', department: 'Human Resources' },
            'compliance@generalhospital.org': { role: 'admin', name: 'Compliance Office', department: 'Regulatory Affairs' },
            'admin.lee@generalhospital.org': { role: 'admin', name: 'David Lee', department: 'Medical Records' },
            
            // IT Staff
            'it.support@generalhospital.org': { role: 'it', name: 'IT Support Team', department: 'Information Technology' },
            'it.security@generalhospital.org': { role: 'it', name: 'IT Security Team', department: 'Cybersecurity' },
            'sysadmin@generalhospital.org': { role: 'it', name: 'System Administrator', department: 'IT Infrastructure' },
            'it.miller@generalhospital.org': { role: 'it', name: 'Kevin Miller', department: 'Network Administration' },
            
            // Maintenance/Janitorial
            'maintenance.supervisor@generalhospital.org': { role: 'janitor', name: 'Maintenance Supervisor', department: 'Facilities' },
            'janitor.lopez@generalhospital.org': { role: 'janitor', name: 'Carlos Lopez', department: 'Environmental Services' },
            'facilities@generalhospital.org': { role: 'janitor', name: 'Facilities Management', department: 'Building Operations' },
            'cleaning.crew@generalhospital.org': { role: 'janitor', name: 'Cleaning Crew', department: 'Housekeeping' },
            
            // Security Personnel
            'security.chief@generalhospital.org': { role: 'security', name: 'Security Chief', department: 'Hospital Security' },
            'security.desk@generalhospital.org': { role: 'security', name: 'Security Desk', department: 'Access Control' },
            'guard.adams@generalhospital.org': { role: 'security', name: 'John Adams', department: 'Security Patrol' },
            
            // Billing Department
            'billing@generalhospital.org': { role: 'billing', name: 'Billing Department', department: 'Revenue Cycle' },
            'billing.manager@generalhospital.org': { role: 'billing', name: 'Billing Manager', department: 'Financial Services' },
            'insurance.claims@generalhospital.org': { role: 'billing', name: 'Insurance Claims', department: 'Claims Processing' },
            'billing.rodriguez@generalhospital.org': { role: 'billing', name: 'Ana Rodriguez', department: 'Patient Billing' },
            
            // Pharmacy Staff
            'pharmacy.chief@generalhospital.org': { role: 'pharmacy', name: 'Chief Pharmacist', department: 'Hospital Pharmacy' },
            'pharmacy.tech@generalhospital.org': { role: 'pharmacy', name: 'Pharmacy Technician', department: 'Medication Services' },
            'pharmacist.white@generalhospital.org': { role: 'pharmacy', name: 'Dr. Susan White, PharmD', department: 'Clinical Pharmacy' },
            
            // Lab Technicians
            'lab.supervisor@generalhospital.org': { role: 'lab', name: 'Lab Supervisor', department: 'Laboratory Services' },
            'lab.tech@generalhospital.org': { role: 'lab', name: 'Lab Technician', department: 'Clinical Lab' },
            'pathology@generalhospital.org': { role: 'lab', name: 'Pathology Department', department: 'Anatomical Pathology' },
            'lab.jones@generalhospital.org': { role: 'lab', name: 'Michelle Jones, MLT', department: 'Blood Bank' },
            
            // Radiology Staff
            'radiology.chief@generalhospital.org': { role: 'radiology', name: 'Chief Radiologist', department: 'Imaging Services' },
            'xray.tech@generalhospital.org': { role: 'radiology', name: 'X-Ray Technician', department: 'Diagnostic Imaging' },
            'mri.tech@generalhospital.org': { role: 'radiology', name: 'MRI Technician', department: 'Advanced Imaging' },
            'radiology.clark@generalhospital.org': { role: 'radiology', name: 'Dr. Mark Clark', department: 'Interventional Radiology' }
        };

        // Function to detect recipient role from email address
        function detectRecipientRole(recipientEmail) {
            if (!recipientEmail || typeof recipientEmail !== 'string') {
                return null;
            }
            
            const email = recipientEmail.toLowerCase().trim();
            const userInfo = userDirectory[email];
            
            if (userInfo) {
                return {
                    role: userInfo.role,
                    name: userInfo.name,
                    department: userInfo.department,
                    isKnownUser: true
                };
            }
            
            // Fallback: Try to infer role from email patterns
            if (email.includes('dr.') || email.includes('doctor')) {
                return { role: 'doctor', name: 'Unknown Doctor', department: 'Unknown', isKnownUser: false };
            } else if (email.includes('nurse')) {
                return { role: 'nurse', name: 'Unknown Nurse', department: 'Unknown', isKnownUser: false };
            } else if (email.includes('admin')) {
                return { role: 'admin', name: 'Unknown Admin', department: 'Unknown', isKnownUser: false };
            } else if (email.includes('it.') || email.includes('tech')) {
                return { role: 'it', name: 'Unknown IT Staff', department: 'Unknown', isKnownUser: false };
            } else if (email.includes('maintenance') || email.includes('janitor') || email.includes('facilities')) {
                return { role: 'janitor', name: 'Unknown Maintenance', department: 'Unknown', isKnownUser: false };
            } else if (email.includes('security')) {
                return { role: 'security', name: 'Unknown Security', department: 'Unknown', isKnownUser: false };
            } else if (email.includes('billing') || email.includes('finance')) {
                return { role: 'billing', name: 'Unknown Billing Staff', department: 'Unknown', isKnownUser: false };
            } else if (email.includes('pharmacy') || email.includes('pharm')) {
                return { role: 'pharmacy', name: 'Unknown Pharmacy Staff', department: 'Unknown', isKnownUser: false };
            } else if (email.includes('lab')) {
                return { role: 'lab', name: 'Unknown Lab Staff', department: 'Unknown', isKnownUser: false };
            } else if (email.includes('radiology') || email.includes('xray') || email.includes('imaging')) {
                return { role: 'radiology', name: 'Unknown Radiology Staff', department: 'Unknown', isKnownUser: false };
            }
            
            return null;
        }

        // Load API key from server on page load
        async function loadApiKey() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                openrouterApiKey = config.openrouterApiKey;
                
                console.log('API key loaded:', openrouterApiKey ? 'Yes' : 'No');
                console.log('API key length:', openrouterApiKey ? openrouterApiKey.length : 0);
                if (!openrouterApiKey) {
                    console.error('No API key found! Make sure OPENROUTER_API_KEY is set in .env file');
                }
                
                // Hide API key section if key is available
                if (openrouterApiKey) {
                    const apiKeySection = document.querySelector('.api-key-section');
                    apiKeySection.style.display = 'none';
                }
            } catch (error) {
                console.error('Error loading API key:', error);
                console.log('Running in static mode - API key must be entered manually');
            }
        }

        // Load API key and agent memory when page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadApiKey();
            loadAgentMemory();
            recalculateAccuracy(); // Fix any existing accuracy calculations
            updateResultsDisplay(); // Make sure to update displays
            updateHistoryDisplay();
            updateAgentStatus();
        });

        // Load agent memory from localStorage
        function loadAgentMemory() {
            const saved = localStorage.getItem('healthcareAgentMemory');
            if (saved) {
                agentMemory = { ...agentMemory, ...JSON.parse(saved) };
                console.log('Agent memory loaded:', agentMemory);
            }
            
            // Load history results
            const savedHistory = localStorage.getItem('healthcareHistoryResults');
            if (savedHistory) {
                historyResults = JSON.parse(savedHistory);
                console.log('History results loaded:', historyResults.length, 'items');
            }
            
            // Load active review results
            const savedActiveResults = localStorage.getItem('healthcareActiveResults');
            if (savedActiveResults) {
                analysisResults = JSON.parse(savedActiveResults);
                console.log('Active review results loaded:', analysisResults.length, 'items');
            }
        }

        // Save agent memory to localStorage
        function saveAgentMemory() {
            localStorage.setItem('healthcareAgentMemory', JSON.stringify(agentMemory));
            localStorage.setItem('healthcareHistoryResults', JSON.stringify(historyResults));
            localStorage.setItem('healthcareActiveResults', JSON.stringify(analysisResults));
        }

        async function analyzeEmail() {
            const sender = document.getElementById('sender').value.trim();
            const subject = document.getElementById('subject').value.trim();
            const body = document.getElementById('body').value.trim();
            const recipientEmail = document.getElementById('recipientEmail').value.trim();

            if (!openrouterApiKey) {
                alert('OpenRouter API key not configured. Please ensure OPENROUTER_API_KEY is set in environment variables.');
                return;
            }

            if (!sender || !subject || !body || !recipientEmail) {
                alert('Please fill in all fields: sender, recipient, subject, and email body.');
                return;
            }

            // Detect recipient role automatically
            const recipientInfo = detectRecipientRole(recipientEmail);
            if (!recipientInfo) {
                alert('Unable to determine recipient role. Please check the recipient email address.');
                return;
            }

            const userRole = recipientInfo.role;

            const analyzeBtn = document.querySelector('.analyze-btn');
            const loading = document.getElementById('loading');

            analyzeBtn.disabled = true;
            loading.style.display = 'block';

            try {
                // Multi-step agentic analysis
                const result = await performAgenticAnalysis(openrouterApiKey, sender, subject, body, userRole);
                
                // Add to results array
                const analysisResult = {
                    id: Date.now(),
                    sender: sender,
                    subject: subject,
                    body: body,
                    recipientEmail: recipientEmail,
                    recipientInfo: recipientInfo,
                    classification: result.classification,
                    confidence: result.confidence,
                    comment: result.comment,
                    reasoningReport: result.reasoningReport || null,
                    feedback: null,
                    timestamp: new Date().toLocaleString(),
                    agentActions: result.agentActions || [],
                    learningApplied: result.learningApplied || false,
                    threatIntel: result.threatIntel || null,
                    roleCheck: result.roleCheck || null,
                    userRole: result.userRole || userRole
                };
                
                analysisResults.unshift(analysisResult);
                
                // Update agent performance metrics
                agentMemory.performanceMetrics.totalAnalyzed++;
                
                // Track security metrics
                if (result.classification === 'Phishing') {
                    agentMemory.performanceMetrics.phishingCaught++;
                }
                if (result.threatIntel && result.threatIntel.threatLevel === 'HIGH') {
                    agentMemory.performanceMetrics.highThreatEmails++;
                }
                if (result.threatIntel && result.threatIntel.threatScore > 0) {
                    agentMemory.performanceMetrics.securityThreatsBlocked++;
                }
                
                // Only auto-move safe emails - learned patterns still need review for safety
                if (result.classification === 'Safe') {
                    // Safe emails always auto-move
                    moveToHistory(analysisResult, 'auto_safe');
                }
                // Note: Suspicious/Phishing emails with learned patterns still require manual review
                // This follows the "fail-safe default" principle - unsure? -> quarantine for review
                
                saveAgentMemory();

                // Update display
                updateResultsDisplay();
                updateHistoryDisplay();
                updateAgentStatus();
                
                // Save active results to persist review queue
                saveAgentMemory();
                
                // Clear form
                document.getElementById('recipientEmail').value = '';
                document.getElementById('sender').value = '';
                document.getElementById('subject').value = '';
                document.getElementById('body').value = '';
                document.getElementById('recipientInfo').style.display = 'none';

            } catch (error) {
                console.error('Analysis error:', error);
                alert('Error analyzing email: ' + error.message);
            } finally {
                analyzeBtn.disabled = false;
                loading.style.display = 'none';
            }
        }

        // Multi-step agentic analysis with learning and autonomous actions
        async function performAgenticAnalysis(apiKey, sender, subject, body, userRole) {
            console.log('ü§ñ Agent starting multi-step analysis...');
            
            // Step 1: Role-based Context Check
            const roleCheck = checkRoleAlignment(userRole, sender, subject, body);
            console.log('üë§ Role alignment result:', roleCheck);
            
            // Step 2: Pattern Recognition - Check learned patterns
            const patternMatch = checkLearnedPatterns(sender, subject, body);
            console.log('üìä Pattern recognition result:', patternMatch);
            
            // Step 3: Threat Intelligence Check
            const threatIntel = await checkThreatIntelligence(sender, subject, body);
            console.log('üîç Threat intelligence result:', threatIntel);
            
            // Step 4: AI Analysis with context
            const aiResult = await analyzeWithAI(apiKey, sender, subject, body, patternMatch, threatIntel, roleCheck, userRole);
            console.log('üß† AI analysis result:', aiResult);
            
            // Step 5: Autonomous Decision Making
            const agentActions = determineAutonomousActions(aiResult, patternMatch, threatIntel, roleCheck);
            console.log('‚ö° Autonomous actions:', agentActions);
            
            // Step 5: Apply Learning Context
            const learningApplied = applyLearnedContext(aiResult, patternMatch);
            
            return {
                ...aiResult,
                agentActions,
                learningApplied,
                patternMatch,
                threatIntel,
                roleCheck,
                userRole
            };
        }

        // Check learned patterns from previous feedback
        function checkLearnedPatterns(sender, subject, body) {
            const emailHash = generateEmailHash(sender, subject, body);
            
            // Check for exact matches
            if (agentMemory.learnedPatterns[emailHash]) {
                return {
                    type: 'exact_match',
                    confidence: 95,
                    classification: agentMemory.learnedPatterns[emailHash].classification,
                    reason: 'Previously analyzed email'
                };
            }
            
            // Check for sender patterns
            const senderPattern = agentMemory.learnedPatterns[`sender:${sender}`];
            if (senderPattern && senderPattern.count > 2) {
                return {
                    type: 'sender_pattern',
                    confidence: Math.min(85, 60 + (senderPattern.count * 5)),
                    classification: senderPattern.classification,
                    reason: `Known ${senderPattern.classification.toLowerCase()} sender (${senderPattern.count} instances)`
                };
            }
            
            // Check for subject patterns
            const subjectKeywords = extractKeywords(subject);
            for (const keyword of subjectKeywords) {
                const keywordPattern = agentMemory.learnedPatterns[`keyword:${keyword}`];
                if (keywordPattern && keywordPattern.count > 1) {
                    return {
                        type: 'keyword_pattern',
                        confidence: Math.min(75, 50 + (keywordPattern.count * 10)),
                        classification: keywordPattern.classification,
                        reason: `Known ${keywordPattern.classification.toLowerCase()} keyword pattern`
                    };
                }
            }
            
            return null;
        }

        // Role-based context validation
        function checkRoleAlignment(userRole, sender, subject, body) {
            const rolePatterns = {
                'nurse': {
                    expected: ['patient', 'medication', 'schedule', 'shift', 'care plan', 'nursing', 'treatment', 'vital signs'],
                    suspicious: ['financial', 'billing', 'payroll', 'hr policy', 'employee benefits', 'maintenance request'],
                    highRisk: ['presurgery information', 'surgical procedure', 'anesthesia protocol']
                },
                'doctor': {
                    expected: ['patient', 'diagnosis', 'treatment', 'medical record', 'consultation', 'surgery', 'prescription', 'clinical'],
                    suspicious: ['maintenance', 'janitorial', 'facilities', 'parking', 'cafeteria'],
                    highRisk: ['billing dispute', 'insurance claim', 'employee termination']
                },
                'admin': {
                    expected: ['policy', 'meeting', 'schedule', 'announcement', 'form', 'procedure', 'administrative'],
                    suspicious: ['patient diagnosis', 'medical procedure', 'surgery details', 'medication dosage'],
                    highRisk: ['clinical protocol', 'patient treatment plan', 'medical emergency']
                },
                'it': {
                    expected: ['system', 'network', 'software', 'security', 'update', 'maintenance', 'backup', 'technical'],
                    suspicious: ['patient care', 'medical diagnosis', 'nursing shift', 'surgery schedule'],
                    highRisk: ['clinical decision', 'patient treatment', 'medical emergency']
                },
                'janitor': {
                    expected: ['cleaning', 'maintenance', 'supplies', 'schedule', 'safety', 'facilities', 'equipment'],
                    suspicious: ['patient information', 'medical record', 'treatment plan', 'diagnosis'],
                    highRisk: ['presurgery information', 'patient data', 'medical records', 'clinical protocol', 'surgery details']
                },
                'security': {
                    expected: ['incident', 'safety', 'access', 'patrol', 'emergency', 'visitor', 'security protocol'],
                    suspicious: ['patient treatment', 'medical procedure', 'clinical decision', 'medication'],
                    highRisk: ['patient diagnosis', 'surgery details', 'medical records']
                },
                'billing': {
                    expected: ['invoice', 'payment', 'insurance', 'claim', 'billing', 'financial', 'account'],
                    suspicious: ['clinical protocol', 'patient care', 'medical treatment', 'nursing'],
                    highRisk: ['patient diagnosis', 'medical procedure', 'treatment plan']
                },
                'pharmacy': {
                    expected: ['medication', 'prescription', 'drug', 'pharmacy', 'dosage', 'pharmaceutical'],
                    suspicious: ['maintenance', 'facilities', 'security incident', 'administrative policy'],
                    highRisk: ['surgery details', 'non-medication medical procedures']
                },
                'lab': {
                    expected: ['lab result', 'test', 'specimen', 'analysis', 'laboratory', 'sample'],
                    suspicious: ['billing', 'administrative', 'maintenance', 'security'],
                    highRisk: ['surgery details', 'treatment planning', 'non-diagnostic procedures']
                },
                'radiology': {
                    expected: ['imaging', 'scan', 'x-ray', 'mri', 'ct', 'radiology', 'image'],
                    suspicious: ['billing dispute', 'maintenance', 'administrative', 'security'],
                    highRisk: ['non-imaging medical procedures', 'surgery details']
                }
            };

            const roleConfig = rolePatterns[userRole];
            if (!roleConfig) {
                return null;
            }

            const emailText = `${subject} ${body}`.toLowerCase();
            
            // Check for high-risk content (strong role mismatch)
            const highRiskMatches = roleConfig.highRisk.filter(keyword => 
                emailText.includes(keyword.toLowerCase())
            );
            
            if (highRiskMatches.length > 0) {
                return {
                    type: 'role_mismatch',
                    severity: 'high',
                    confidence: 85,
                    reason: `High-risk content for ${userRole}: Contains "${highRiskMatches.join(', ')}" which is inappropriate for this role`,
                    classification: 'Suspicious',
                    roleMismatch: true,
                    matchedKeywords: highRiskMatches
                };
            }

            // Check for suspicious content (moderate role mismatch)
            const suspiciousMatches = roleConfig.suspicious.filter(keyword => 
                emailText.includes(keyword.toLowerCase())
            );
            
            if (suspiciousMatches.length > 1) {
                return {
                    type: 'role_mismatch',
                    severity: 'moderate',
                    confidence: 65,
                    reason: `Content may be inappropriate for ${userRole}: Contains "${suspiciousMatches.join(', ')}"`,
                    classification: 'Suspicious',
                    roleMismatch: true,
                    matchedKeywords: suspiciousMatches
                };
            }

            // Check for expected content (role alignment)
            const expectedMatches = roleConfig.expected.filter(keyword => 
                emailText.includes(keyword.toLowerCase())
            );
            
            if (expectedMatches.length > 0) {
                return {
                    type: 'role_alignment',
                    severity: 'good',
                    confidence: 75,
                    reason: `Content appropriate for ${userRole}: Contains expected keywords "${expectedMatches.join(', ')}"`,
                    classification: null, // Don't override classification for good alignment
                    roleMismatch: false,
                    matchedKeywords: expectedMatches
                };
            }

            return null;
        }

        // Enhanced threat intelligence check with security analysis
        async function checkThreatIntelligence(sender, subject, body) {
            const domain = sender.split('@')[1];
            
            // 1. Domain Analysis
            const suspiciousDomains = ['medical-alert.net', 'hospital-security.com', 'healthcare-emergency.net', 'medicare-updates.org'];
            const isSuspiciousDomain = suspiciousDomains.includes(domain);
            
            // 2. Link Analysis (simulated)
            const links = extractLinks(body);
            const suspiciousLinks = links.filter(link => {
                return link.includes('h0spital') || // Lookalike domains
                       link.includes('hospita1') ||
                       link.includes('medica1') ||
                       link.includes('bit.ly') || // Shortened URLs
                       link.includes('tinyurl');
            });
            
            // 3. Header Analysis (simulated)
            const headerAnalysis = analyzeHeaders(sender, subject);
            
            // 4. Content Analysis
            const bodyLower = body.toLowerCase();
            const phishingKeywords = ['urgent', 'immediately', 'click here', 'verify', 'suspended', 'violation', 'compromise', 'breach'];
            const phishingScore = phishingKeywords.filter(keyword => bodyLower.includes(keyword)).length;
            
            // 5. MIME/Attachment Analysis (simulated)
            const attachmentAnalysis = analyzeAttachments(body);
            
            // 6. Threat Level Calculation
            let threatScore = 0;
            if (isSuspiciousDomain) threatScore += 40;
            if (suspiciousLinks.length > 0) threatScore += 30;
            if (headerAnalysis.spoofing) threatScore += 25;
            if (phishingScore > 2) threatScore += 20;
            if (attachmentAnalysis.suspicious) threatScore += 15;
            
            const threatLevel = threatScore >= 70 ? 'HIGH' : threatScore >= 40 ? 'MEDIUM' : 'LOW';
            
            return {
                suspiciousDomain: isSuspiciousDomain,
                phishingScore,
                suspiciousLinks: suspiciousLinks.length,
                headerIssues: headerAnalysis.issues,
                attachmentIssues: attachmentAnalysis.issues,
                threatScore,
                threatLevel,
                confidence: Math.min(95, threatScore + 10)
            };
        }

        // Extract links from email body
        function extractLinks(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return text.match(urlRegex) || [];
        }

        // Analyze email headers for spoofing
        function analyzeHeaders(sender, subject) {
            const issues = [];
            let spoofing = false;
            
            // Check for suspicious sender patterns
            if (sender.includes('noreply') && subject.toLowerCase().includes('urgent')) {
                issues.push('Urgent subject from noreply sender');
                spoofing = true;
            }
            
            // Check for suspicious domains
            const suspiciousPatterns = ['@gmail.com', '@yahoo.com', '@hotmail.com'];
            if (suspiciousPatterns.some(pattern => sender.includes(pattern)) && subject.toLowerCase().includes('hospital')) {
                issues.push('Personal email claiming to be from hospital');
                spoofing = true;
            }
            
            return { issues, spoofing };
        }

        // Analyze attachments (simulated)
        function analyzeAttachments(text) {
            const issues = [];
            let suspicious = false;
            
            // Look for attachment mentions
            const attachmentKeywords = ['attachment', 'document', 'file', '.exe', '.zip', '.pdf'];
            const hasAttachments = attachmentKeywords.some(keyword => text.toLowerCase().includes(keyword));
            
            if (hasAttachments && text.toLowerCase().includes('password')) {
                issues.push('Password-protected attachment');
                suspicious = true;
            }
            
            if (text.toLowerCase().includes('macro') || text.toLowerCase().includes('enable content')) {
                issues.push('Macro-enabled document');
                suspicious = true;
            }
            
            return { issues, suspicious };
        }

        // Determine autonomous actions based on analysis
        function determineAutonomousActions(aiResult, patternMatch, threatIntel, roleCheck) {
            const actions = [];
            
            // Auto-quarantine high-confidence phishing
            if (aiResult.classification === 'Phishing' && aiResult.confidence >= agentMemory.autoActions.quarantineThreshold) {
                actions.push({
                    type: 'quarantine',
                    reason: `High-confidence phishing (${aiResult.confidence}%)`,
                    timestamp: new Date().toISOString()
                });
            }
            
            // Escalate high-threat situations
            if (threatIntel.threatLevel === 'HIGH' || aiResult.confidence >= agentMemory.autoActions.escalationThreshold) {
                actions.push({
                    type: 'escalate',
                    reason: 'High threat level detected',
                    timestamp: new Date().toISOString()
                });
            }
            
            // Apply pattern-based actions
            if (patternMatch && patternMatch.confidence > 80) {
                actions.push({
                    type: 'pattern_based',
                    reason: patternMatch.reason,
                    timestamp: new Date().toISOString()
                });
            }
            
            // Role-based escalation
            if (roleCheck && roleCheck.roleMismatch) {
                if (roleCheck.severity === 'high') {
                    actions.push({
                        type: 'role_escalate',
                        reason: `ROLE MISMATCH: ${roleCheck.reason}`,
                        timestamp: new Date().toISOString()
                    });
                } else if (roleCheck.severity === 'moderate') {
                    actions.push({
                        type: 'role_review',
                        reason: `Role Review: ${roleCheck.reason}`,
                        timestamp: new Date().toISOString()
                    });
                }
            }
            
            return actions;
        }

        // Apply learned context to improve analysis
        function applyLearnedContext(aiResult, patternMatch) {
            let learningApplied = false;
            
            if (patternMatch && patternMatch.confidence > 70) {
                // Boost confidence if pattern matches
                aiResult.confidence = Math.min(95, aiResult.confidence + 10);
                aiResult.comment = `[Learning Applied] ${aiResult.comment}`;
                learningApplied = true;
                
                // For exact matches with high confidence, use the learned classification
                if (patternMatch.type === 'exact_match' && patternMatch.confidence >= 95) {
                    aiResult.classification = patternMatch.classification;
                    aiResult.confidence = patternMatch.confidence;
                    aiResult.comment = `[Auto-Classified] Previously analyzed: ${patternMatch.classification}`;
                }
            }
            
            return learningApplied;
        }

        // Helper functions
        function generateEmailHash(sender, subject, body) {
            return btoa(sender + subject + body).substring(0, 16);
        }

        function extractKeywords(text) {
            return text.toLowerCase().split(/\W+/).filter(word => word.length > 3);
        }

        async function analyzeWithAI(apiKey, sender, subject, body, patternMatch = null, threatIntel = null, roleCheck = null, userRole = null) {
            // Try multiple free models in order of preference
            const freeModels = [
                'microsoft/wizardlm-2-8x22b:free',
                'meta-llama/llama-3.1-8b-instruct:free', 
                'google/gemma-2-9b-it:free',
                'qwen/qwen-2-7b-instruct:free',
                'huggingfaceh4/zephyr-7b-beta:free'
            ];
            const emailContent = `Subject: ${subject}\nFrom: ${sender}\n\n${body}`;
            
            // Build role context information
            let roleContext = '';
            if (userRole && roleCheck) {
                roleContext = `
Recipient Role: ${userRole}
Role Analysis: ${roleCheck ? roleCheck.reason : 'No role issues detected'}
${roleCheck && roleCheck.roleMismatch ? 'WARNING: This email content may be inappropriate for the recipient\'s role!' : ''}
`;
            }

            // Build threat context for detailed analysis
            let threatContext = '';
            if (threatIntel) {
                threatContext = `
Previous Analysis Context:
- Threat Score: ${threatIntel.threatScore}/100
- Suspicious Links: ${threatIntel.suspiciousLinks}
- Header Issues: ${threatIntel.headerIssues.join(', ')}
- Attachment Issues: ${threatIntel.attachmentIssues.join(', ')}
`;
            }

            // Create optimized prompt with clearer instructions
            const prompt = `Healthcare email security analysis. Respond with valid JSON only.

EMAIL DATA:
From: ${sender}
To: ${userRole || 'staff'} 
Subject: ${subject}
Body: ${body}
${roleCheck ? `Role Issue: ${roleCheck.reason}` : ''}
${threatIntel ? `Threats: ${threatIntel.threatScore}/100, ${threatIntel.suspiciousLinks} suspicious links` : ''}

REQUIRED JSON OUTPUT:
{
  "classification": "Safe",
  "confidence": 85,
  "comment": "Brief explanation",
  "reasoningReport": {
    "summary": "2-sentence analysis summary",
    "threatIndicators": ["threat1", "threat2"],
    "roleAnalysis": "Role appropriateness explanation", 
    "technicalFindings": ["finding1", "finding2"],
    "recommendation": "Clear action recommendation"
  }
}

RULES: Safe=legitimate, Suspicious=unclear/inappropriate, Phishing=malicious. Role mismatches = Suspicious.`;

            // Try models in sequence until one works
            let response = null;
            let lastError = null;
            
            for (const model of freeModels) {
                console.log(`Trying model: ${model}`);
                
                try {
                    response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`,
                            'HTTP-Referer': window.location.origin,
                            'X-Title': 'Healthcare Email Defense Demo'
                        },
                        body: JSON.stringify({
                            model: model,
                            max_tokens: 800,
                            temperature: 0.1,
                            messages: [
                                {
                                    role: 'user',
                                    content: prompt
                                }
                            ]
                        })
                    });
                    
                    if (response.ok) {
                        console.log(`‚úÖ Successfully using model: ${model}`);
                        break;
                    } else {
                        const errorData = await response.json();
                        console.log(`‚ùå Model ${model} failed:`, errorData);
                        lastError = errorData;
                        response = null;
                    }
                } catch (error) {
                    console.log(`‚ùå Model ${model} error:`, error);
                    lastError = error;
                    response = null;
                }
            }
            
            if (!response) {
                throw new Error(`All models failed. Last error: ${JSON.stringify(lastError)}`);
            }

            console.log('API Response status:', response.status);
            console.log('API Response headers:', response.headers);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error response:', errorText);
                throw new Error(`API request failed: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const data = await response.json();
            console.log('Full API response:', data);
            const content = data.choices[0].message.content;
            
            // Check if response was truncated
            if (data.choices[0].finish_reason === 'length') {
                console.warn('‚ö†Ô∏è AI response was truncated due to length limits');
            }
            
            try {
                // Clean the response content
                const cleanContent = content.trim();
                console.log('AI Response:', cleanContent);
                console.log('Response length:', cleanContent.length);
                console.log('Contains reasoningReport?', cleanContent.includes('reasoningReport'));
                
                // Try multiple JSON extraction methods
                let result;
                let jsonString = cleanContent;
                
                // Method 1: Try parsing the entire response
                try {
                    result = JSON.parse(jsonString);
                } catch {
                    // Method 2: Extract JSON using regex
                    const jsonMatch = jsonString.match(/\{[\s\S]*?\}/);
                    if (jsonMatch) {
                        try {
                            result = JSON.parse(jsonMatch[0]);
                        } catch {
                            // Method 3: Try to find JSON between backticks or code blocks
                            const codeBlockMatch = jsonString.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
                            if (codeBlockMatch) {
                                result = JSON.parse(codeBlockMatch[1]);
                            } else {
                                throw new Error('No valid JSON found');
                            }
                        }
                    } else {
                        throw new Error('No JSON pattern found');
                    }
                }
                
                console.log('Parsed result:', result);
                
                // Validate and normalize the result structure
                if (result && typeof result === 'object') {
                    const classification = result.classification || 'Suspicious';
                    const confidence = Math.round(Number(result.confidence) || 70);
                    const comment = result.comment || 'Analysis completed';
                    
                    // Ensure classification is one of the valid values
                    const validClassifications = ['Safe', 'Suspicious', 'Phishing'];
                    const finalClassification = validClassifications.includes(classification) 
                        ? classification 
                        : 'Suspicious';
                    
                    // Ensure confidence is within reasonable bounds
                    const finalConfidence = Math.max(50, Math.min(95, confidence));
                    
                    return {
                        classification: finalClassification,
                        confidence: finalConfidence,
                        comment: comment,
                        reasoningReport: result.reasoningReport || {
                            summary: `AI analysis completed. Email classified as ${finalClassification} with ${finalConfidence}% confidence.`,
                            threatIndicators: result.threatIndicators || [],
                            roleAnalysis: result.roleAnalysis || `Content analyzed for ${userRole || 'healthcare worker'} role.`,
                            technicalFindings: result.technicalFindings || ['AI-based content analysis performed'],
                            recommendation: result.recommendation || `${finalClassification === 'Phishing' ? 'Quarantine immediately' : finalClassification === 'Safe' ? 'Allow delivery' : 'Manual review recommended'}`
                        }
                    };
                } else {
                    throw new Error('Invalid result structure');
                }
            } catch (parseError) {
                console.warn('Failed to parse AI response:', parseError);
                console.log('Raw response:', content);
                
                // Improved fallback parsing - analyze the email content directly
                const lowerContent = content.toLowerCase();
                const emailLower = emailContent.toLowerCase();
                let classification = 'Suspicious';
                let confidence = 70;
                let comment = 'AI analysis completed - manual review recommended';
                
                // Analyze email content for threat indicators
                const phishingKeywords = ['urgent', 'immediately', 'click here', 'verify account', 'suspended', 'violation', 'compromise', 'breach', 'password expired', 'account locked', 'click here', 'verify now', 'action required', 'account suspended'];
                const safeKeywords = ['appointment', 'schedule', 'medical', 'patient', 'doctor', 'nurse', 'hospital', 'clinic', 'treatment', 'prescription', 'hipaa', 'compliance', 'training', 'reminder', 'policy', 'staff', 'internal', 'meeting', 'conference'];
                
                // Check for legitimate hospital/healthcare domains
                const legitimateDomains = ['generalhospital.org', 'hospital.org', 'clinic.org', 'medical.org', 'healthcare.org', '.gov', '.edu'];
                const isLegitimateDomain = legitimateDomains.some(domain => sender.toLowerCase().includes(domain));
                
                const phishingScore = phishingKeywords.filter(keyword => emailLower.includes(keyword)).length;
                const safeScore = safeKeywords.filter(keyword => emailLower.includes(keyword)).length;
                
                // Determine classification based on content analysis
                // Priority 1: Legitimate domains with healthcare content
                if (isLegitimateDomain && (safeScore >= 1 || emailLower.includes('hipaa') || emailLower.includes('training') || emailLower.includes('compliance'))) {
                    classification = 'Safe';
                    confidence = Math.max(80, 85 + safeScore * 2);
                    comment = 'Legitimate healthcare domain with appropriate content';
                }
                // Priority 2: Clear phishing indicators
                else if (phishingScore >= 2 || emailLower.includes('phishing') || emailLower.includes('malicious')) {
                    classification = 'Phishing';
                    confidence = Math.min(95, 75 + (phishingScore * 5));
                    comment = 'Multiple threat indicators detected';
                }
                // Priority 3: Strong safe indicators
                else if (safeScore >= 2 && phishingScore === 0) {
                    classification = 'Safe';
                    confidence = Math.max(70, 80 - (safeScore * 2));
                    comment = 'Appears to be legitimate healthcare communication';
                }
                // Priority 4: AI explicitly marked as safe
                else if (lowerContent.includes('safe') && !lowerContent.includes('not safe')) {
                    classification = 'Safe';
                    confidence = 70;
                    comment = 'Marked as safe by AI analysis';
                }
                // Priority 5: AI explicitly marked as suspicious
                else if (lowerContent.includes('suspicious')) {
                    classification = 'Suspicious';
                    confidence = 75;
                    comment = 'Suspicious indicators detected';
                }
                // Priority 6: Default based on content analysis
                else {
                    if (phishingScore > safeScore) {
                        classification = 'Suspicious';
                        confidence = 65 + phishingScore * 5;
                    } else if (safeScore > 0) {
                        classification = 'Safe';
                        confidence = 60 + safeScore * 3;
                    } else {
                        classification = 'Suspicious';
                        confidence = 70;
                        comment = 'No clear indicators - defaulting to suspicious for safety';
                    }
                }
                
                // Ensure confidence stays within bounds
                confidence = Math.max(50, Math.min(95, confidence));
                
                // Generate reasoning report for fallback analysis
                const foundPhishingKeywords = phishingKeywords.filter(keyword => emailLower.includes(keyword));
                const foundSafeKeywords = safeKeywords.filter(keyword => emailLower.includes(keyword));
                
                const reasoningReport = {
                    summary: `Fallback analysis completed due to AI unavailability. Email classified as ${classification} with ${confidence}% confidence based on content pattern analysis.`,
                    threatIndicators: [
                        ...(foundPhishingKeywords.length > 0 ? [`Phishing keywords detected: ${foundPhishingKeywords.join(', ')}`] : []),
                        ...(phishingScore >= 2 ? ['Multiple urgency indicators present'] : []),
                        ...(!isLegitimateDomain ? ['Sender domain not in trusted healthcare domain list'] : [])
                    ],
                    roleAnalysis: roleCheck ? roleCheck.reason : `Content analyzed for ${userRole || 'healthcare worker'} role - no specific role concerns detected in fallback mode`,
                    technicalFindings: [
                        `Phishing keyword score: ${phishingScore}`,
                        `Healthcare keyword score: ${safeScore}`,
                        `Domain legitimacy: ${isLegitimateDomain ? 'Trusted healthcare domain' : 'External domain'}`,
                        'Note: Technical analysis limited in fallback mode'
                    ],
                    recommendation: classification === 'Phishing' ? 
                        'Quarantine immediately and alert security team due to multiple threat indicators' :
                        classification === 'Safe' ?
                        'Allow delivery - content appears legitimate for healthcare environment' :
                        'Manual review recommended - unclear threat level requires human analysis'
                };
                
                return {
                    classification,
                    confidence,
                    comment,
                    reasoningReport
                };
            }
        }

        function updateResultsDisplay() {
            const container = document.getElementById('results-container');
            
            if (analysisResults.length === 0) {
                container.innerHTML = '<div class="no-results">No emails analyzed yet. Submit an email above to see results.</div>';
                return;
            }

            const tableHTML = `
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Sender</th>
                            <th>Subject</th>
                            <th>Classification</th>
                            <th>Confidence</th>
                            <th>AI Comment</th>
                            <th>Agent Actions</th>
                            <th>IT Review</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${analysisResults.map(result => `
                            <tr>
                                <td>${result.sender}</td>
                                <td>${result.subject}</td>
                                <td>
                                    <span class="classification ${result.classification.toLowerCase()}">
                                        ${result.classification}
                                    </span>
                                    ${result.learningApplied ? '<div class="learning-indicator">üß† Learning Applied</div>' : ''}
                                </td>
                                <td>
                                    <span class="confidence">${result.confidence}%</span>
                                </td>
                                <td>
                                    <div class="ai-comment">
                                        <div class="brief-comment">${result.comment}</div>
                                        ${result.reasoningReport ? `
                                            <button class="reasoning-report-btn" onclick="openReasoningReport(${result.id})" title="View detailed analysis">
                                                üìä View Reasoning Report
                                            </button>
                                        ` : ''}
                                    </div>
                                    ${result.threatIntel ? `
                                        <div class="security-details">
                                            <small>Threat Score: ${result.threatIntel.threatScore}/100</small>
                                            ${result.threatIntel.suspiciousLinks > 0 ? `<br><small>‚ö†Ô∏è ${result.threatIntel.suspiciousLinks} suspicious links</small>` : ''}
                                            ${result.threatIntel.headerIssues.length > 0 ? `<br><small>‚ö†Ô∏è ${result.threatIntel.headerIssues.length} header issues</small>` : ''}
                                            ${result.threatIntel.attachmentIssues.length > 0 ? `<br><small>‚ö†Ô∏è ${result.threatIntel.attachmentIssues.length} attachment issues</small>` : ''}
                                        </div>
                                    ` : ''}
                                    ${result.roleCheck && result.roleCheck.roleMismatch ? `
                                        <div class="role-warning ${result.roleCheck.severity}">
                                            <strong>‚ö†Ô∏è ROLE MISMATCH:</strong> ${result.roleCheck.reason}
                                            <br><small>Recipient: ${result.userRole}</small>
                                        </div>
                                    ` : result.userRole ? `
                                        <div class="role-info">
                                            <small>üë§ Recipient: ${result.userRole}</small>
                                        </div>
                                    ` : ''}
                                </td>
                                <td>
                                    <div class="agent-actions">
                                        ${result.agentActions && result.agentActions.length > 0 ? 
                                            result.agentActions.map(action => 
                                                `<span class="agent-action ${action.type}">${action.type.replace('_', ' ')}</span>`
                                            ).join('') : 
                                            '<span style="color: #718096; font-style: italic;">No actions</span>'
                                        }
                                    </div>
                                </td>
                                <td>
                                    <div class="feedback-section">
                                        <button class="review-btn" onclick="openReview(${result.id})" title="Review full email">
                                            üëÅÔ∏è Review
                                        </button>
                                        <div class="feedback-buttons">
                                            <button class="feedback-btn correct ${result.feedback === 'correct' ? 'selected' : ''}" 
                                                    onclick="confirmFeedback(${result.id}, 'correct', '${result.classification}');">
                                                üõ°Ô∏è Quarantine
                                            </button>
                                            <button class="feedback-btn incorrect ${result.feedback === 'incorrect' ? 'selected' : ''}" 
                                                    onclick="confirmFeedback(${result.id}, 'incorrect', '${result.classification}');">
                                                üìß Send Email
                                            </button>
                                        </div>
                                    </div>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            container.innerHTML = tableHTML;
        }

        function setFeedback(resultId, feedback) {
            console.log('setFeedback called with:', { resultId, feedback });
            console.log('Type of resultId:', typeof resultId);
            console.log('Current analysisResults:', analysisResults.map(r => ({ id: r.id, type: typeof r.id })));
            
            const result = analysisResults.find(r => r.id == resultId); // Use == instead of === to handle type coercion
            console.log('Found result:', result);
            
            if (result) {
                // Only update metrics if this is the first feedback for this email
                const isFirstFeedback = !result.feedback;
                const previousFeedback = result.feedback;
                
                result.feedback = feedback;
                
                // Learn from feedback
                learnFromFeedback(result, feedback);
                
                // Track false positives
                if (feedback === 'incorrect' && (result.classification === 'Suspicious' || result.classification === 'Phishing')) {
                    agentMemory.performanceMetrics.falsePositives++;
                }
                
                // Note: We'll recalculate accuracy after moving to history
                // This ensures we count only reviewed emails, not all analyzed emails
                
                // Move reviewed email to history
                moveToHistory(result, 'reviewed');
                
                // Recalculate accuracy after moving to history
                recalculateAccuracy();
                
                saveAgentMemory();
                updateResultsDisplay();
                updateHistoryDisplay();
                updateAgentStatus();
            } else {
                console.error('Result not found for ID:', resultId);
                console.error('Available IDs:', analysisResults.map(r => r.id));
                alert('Error: Could not find email to update. Please refresh the page.');
            }
        }

        // Learn from feedback to improve future analysis
        function learnFromFeedback(result, feedback) {
            const sender = result.sender;
            const subject = result.subject;
            const body = result.body;
            const emailHash = generateEmailHash(sender, subject, body);
            
            // Store exact email match
            agentMemory.learnedPatterns[emailHash] = {
                classification: result.classification,
                feedback: feedback,
                timestamp: new Date().toISOString()
            };
            
            // Learn sender patterns
            const senderKey = `sender:${sender}`;
            if (!agentMemory.learnedPatterns[senderKey]) {
                agentMemory.learnedPatterns[senderKey] = {
                    classification: result.classification,
                    count: 0,
                    feedback: feedback
                };
            }
            agentMemory.learnedPatterns[senderKey].count++;
            
            // Learn keyword patterns
            const keywords = extractKeywords(subject + ' ' + body);
            keywords.forEach(keyword => {
                const keywordKey = `keyword:${keyword}`;
                if (!agentMemory.learnedPatterns[keywordKey]) {
                    agentMemory.learnedPatterns[keywordKey] = {
                        classification: result.classification,
                        count: 0,
                        feedback: feedback
                    };
                }
                agentMemory.learnedPatterns[keywordKey].count++;
            });
            
            // Store role-specific patterns
            if (result.userRole) {
                if (!agentMemory.rolePatterns[result.userRole]) {
                    agentMemory.rolePatterns[result.userRole] = {};
                }
                
                // Learn role-specific sender patterns
                const roleSenderKey = `${result.userRole}:sender:${sender}`;
                if (!agentMemory.rolePatterns[result.userRole][roleSenderKey]) {
                    agentMemory.rolePatterns[result.userRole][roleSenderKey] = {
                        classification: result.classification,
                        count: 0,
                        feedback: feedback,
                        lastSeen: new Date().toISOString()
                    };
                }
                agentMemory.rolePatterns[result.userRole][roleSenderKey].count++;
                agentMemory.rolePatterns[result.userRole][roleSenderKey].lastSeen = new Date().toISOString();
                
                // Learn role-specific content patterns for role mismatches
                if (result.roleCheck && result.roleCheck.roleMismatch) {
                    const roleMismatchKey = `${result.userRole}:mismatch:${result.roleCheck.severity}`;
                    if (!agentMemory.rolePatterns[result.userRole][roleMismatchKey]) {
                        agentMemory.rolePatterns[result.userRole][roleMismatchKey] = {
                            classification: result.classification,
                            count: 0,
                            feedback: feedback,
                            lastSeen: new Date().toISOString()
                        };
                    }
                    agentMemory.rolePatterns[result.userRole][roleMismatchKey].count++;
                    agentMemory.rolePatterns[result.userRole][roleMismatchKey].lastSeen = new Date().toISOString();
                    
                    // Track role mismatch metrics
                    agentMemory.performanceMetrics.roleMismatches++;
                }
            }
            
            // Store feedback history
            agentMemory.feedbackHistory.push({
                id: result.id,
                classification: result.classification,
                feedback: feedback,
                timestamp: new Date().toISOString(),
                sender: sender,
                subject: subject,
                userRole: result.userRole || null,
                roleMismatch: result.roleCheck ? result.roleCheck.roleMismatch : false
            });
            
            console.log('üß† Learning from feedback:', feedback, 'for', result.classification, 'role:', result.userRole);
        }

        // Move email to history log
        function moveToHistory(result, reason = 'reviewed') {
            const historyItem = {
                ...result,
                movedToHistory: new Date().toISOString(),
                moveReason: reason
            };
            
            historyResults.unshift(historyItem);
            
            // Remove from active results
            analysisResults = analysisResults.filter(r => r.id !== result.id);
            
            // Save the updated active results
            localStorage.setItem('healthcareActiveResults', JSON.stringify(analysisResults));
            
            console.log('üìã Moved email to history:', reason);
        }

        // Update history display
        function updateHistoryDisplay() {
            const container = document.getElementById('history-container');
            
            if (historyResults.length === 0) {
                container.innerHTML = '<div class="no-results">No emails in history yet. Reviewed emails and safe emails will appear here.</div>';
                return;
            }

            const tableHTML = `
                <table class="results-table history-table">
                    <thead>
                        <tr>
                            <th>Sender</th>
                            <th>Subject</th>
                            <th>Classification</th>
                            <th>Confidence</th>
                            <th>Status</th>
                            <th>Moved</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${historyResults.map(result => `
                            <tr>
                                <td>${result.sender}</td>
                                <td>${result.subject}</td>
                                <td>
                                    <span class="classification ${result.classification.toLowerCase()}">
                                        ${result.classification}
                                    </span>
                                </td>
                                <td>
                                    <span class="confidence">${result.confidence}%</span>
                                </td>
                                <td>
                                    <span class="history-status ${result.moveReason}">
                                        ${result.moveReason === 'auto_safe' ? 'Auto-Safe' : 
                                          result.moveReason === 'auto_learned' ? 'Auto-Learned' :
                                          result.feedback === 'correct' ? 'IT Quarantined' : 'IT Sent'}
                                    </span>
                                </td>
                                <td>
                                    <span class="moved-time">${new Date(result.movedToHistory).toLocaleString()}</span>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            container.innerHTML = tableHTML;
        }

        // Update agent status display
        function updateAgentStatus() {
            const metrics = agentMemory.performanceMetrics;
            const historyCount = historyResults.length;
            const activeCount = analysisResults.length;
            
            const statusHTML = `
                <div class="agent-status">
                    <div class="agent-status-header">
                        <h3>ü§ñ Agent Status</h3>
                        <div class="agent-controls">
                            <button class="refresh-stats-btn" onclick="refreshAgentStats()" title="Refresh stats">
                                üîÑ
                            </button>
                            <button class="clear-history-btn" onclick="clearAllHistory()" title="Clear all history and reset agent">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                    <div class="status-grid">
                        <div class="status-item">
                            <span class="status-label">Emails Analyzed:</span>
                            <span class="status-value">${metrics.totalAnalyzed}</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Accuracy Rate:</span>
                            <span class="status-value">${metrics.accuracyRate.toFixed(1)}%</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Patterns Learned:</span>
                            <span class="status-value">${Object.keys(agentMemory.learnedPatterns).length}</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Active Reviews:</span>
                            <span class="status-value">${activeCount}</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">History Log:</span>
                            <span class="status-value">${historyCount}</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Phishing Caught:</span>
                            <span class="status-value">${metrics.phishingCaught}</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">High Threats:</span>
                            <span class="status-value">${metrics.highThreatEmails}</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">False Positives:</span>
                            <span class="status-value">${metrics.falsePositives}</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Role Mismatches:</span>
                            <span class="status-value">${metrics.roleMismatches || 0}</span>
                        </div>
                    </div>
                    <div class="last-updated">
                        Last updated: ${new Date().toLocaleTimeString()}
                    </div>
                </div>
            `;
            
            let statusContainer = document.getElementById('agent-status');
            if (!statusContainer) {
                statusContainer = document.createElement('div');
                statusContainer.id = 'agent-status';
                document.querySelector('.results-section').insertBefore(statusContainer, document.getElementById('results-container'));
            }
            statusContainer.innerHTML = statusHTML;
        }

        // Refresh agent stats manually
        function refreshAgentStats() {
            console.log('üîÑ Refreshing agent stats...');
            
            // Reload data from localStorage to ensure we have latest
            loadAgentMemory();
            
            // Recalculate accuracy based on actual feedback history
            recalculateAccuracy();
            
            // Update all displays
            updateResultsDisplay();
            updateHistoryDisplay();
            updateAgentStatus();
            
            // Add visual feedback
            const refreshBtn = document.querySelector('.refresh-stats-btn');
            if (refreshBtn) {
                refreshBtn.style.transform = 'rotate(360deg)';
                refreshBtn.style.transition = 'transform 0.5s ease';
                setTimeout(() => {
                    refreshBtn.style.transform = 'rotate(0deg)';
                }, 500);
            }
            
            console.log('‚úÖ Agent stats refreshed');
        }

        // Clear all history and reset agent
        function clearAllHistory() {
            if (!confirm('Are you sure you want to clear all history and reset the agent? This will delete all learned patterns, feedback history, and metrics.')) {
                return;
            }

            console.log('üóëÔ∏è Clearing all history and resetting agent...');
            
            // Reset all data structures
            analysisResults = [];
            historyResults = [];
            generationCounter = 0;
            lastGeneratedType = null;
            
            // Reset agent memory to defaults
            agentMemory = {
                learnedPatterns: {},
                feedbackHistory: [],
                threatIntelligence: {},
                performanceMetrics: {
                    totalAnalyzed: 0,
                    correctPredictions: 0,
                    accuracyRate: 0,
                    phishingCaught: 0,
                    falsePositives: 0,
                    securityThreatsBlocked: 0,
                    highThreatEmails: 0
                },
                autoActions: {
                    quarantineThreshold: 85,
                    escalationThreshold: 90,
                    autoQuarantineEnabled: true
                }
            };
            
            // Clear localStorage
            localStorage.removeItem('healthcareAgentMemory');
            localStorage.removeItem('healthcareHistoryResults');
            localStorage.removeItem('healthcareActiveResults');
            
            // Update all displays
            updateResultsDisplay();
            updateHistoryDisplay();
            updateAgentStatus();
            
            console.log('‚úÖ All history cleared and agent reset');
            
            // Show confirmation message
            const statusContainer = document.getElementById('agent-status');
            if (statusContainer) {
                const originalContent = statusContainer.innerHTML;
                statusContainer.innerHTML = `
                    <div class="agent-status" style="background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);">
                        <h3>‚úÖ Agent Reset Complete</h3>
                        <p style="margin: 10px 0; opacity: 0.9;">All history cleared and agent reset to initial state.</p>
                    </div>
                `;
                
                setTimeout(() => {
                    statusContainer.innerHTML = originalContent;
                    updateAgentStatus();
                }, 3000);
            }
        }

        // Update recipient info display based on email input
        function updateRecipientInfo() {
            const emailInput = document.getElementById('recipientEmail');
            const recipientInfo = document.getElementById('recipientInfo');
            const recipientName = document.getElementById('recipientName');
            const recipientRole = document.getElementById('recipientRole');
            const recipientDepartment = document.getElementById('recipientDepartment');
            const unknownUserWarning = document.getElementById('unknownUserWarning');
            
            const email = emailInput.value.trim();
            
            if (!email) {
                recipientInfo.style.display = 'none';
                return;
            }
            
            const userInfo = detectRecipientRole(email);
            
            if (userInfo) {
                recipientInfo.style.display = 'block';
                recipientName.textContent = userInfo.name;
                recipientRole.textContent = userInfo.role.charAt(0).toUpperCase() + userInfo.role.slice(1);
                recipientDepartment.textContent = userInfo.department;
                
                if (userInfo.isKnownUser) {
                    unknownUserWarning.style.display = 'none';
                    recipientInfo.style.background = '#f0f9ff';
                    recipientInfo.style.borderColor = '#bfdbfe';
                } else {
                    unknownUserWarning.style.display = 'block';
                    recipientInfo.style.background = '#fef5e7';
                    recipientInfo.style.borderColor = '#f6cc8f';
                }
            } else {
                recipientInfo.style.display = 'none';
            }
        }

        // Modal Functions
        function openReview(resultId) {
            const result = analysisResults.find(r => r.id === resultId);
            if (!result) return;

            console.log('Opening review for result:', result);
            console.log('Body content:', result.body);
            console.log('Body type:', typeof result.body);

            // Populate modal
            document.getElementById('modalSender').textContent = result.sender || 'No sender';
            document.getElementById('modalSubject').textContent = result.subject || 'No subject';
            
            const bodyContent = result.body || 'No body content';
            console.log('Body content to display:', bodyContent);
            document.getElementById('modalBody').innerHTML = bodyContent.replace(/\n/g, '<br>');
            
            const classificationSpan = document.getElementById('modalClassification');
            classificationSpan.innerHTML = `<span class="classification ${(result.classification || 'Unknown').toLowerCase()}">${result.classification || 'Unknown'}</span>`;
            
            document.getElementById('modalConfidence').textContent = `${result.confidence || 0}%`;
            document.getElementById('modalThreatScore').textContent = result.threatIntel ? `${result.threatIntel.threatScore}/100` : 'N/A';
            document.getElementById('modalComment').textContent = result.comment || 'No comment available';
            
            // Store result ID for feedback
            document.getElementById('emailModal').dataset.resultId = resultId;
            
            // Show modal
            document.getElementById('emailModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('emailModal').style.display = 'none';
        }


        function setFeedbackFromModal(feedback) {
            const resultId = parseInt(document.getElementById('emailModal').dataset.resultId);
            setFeedback(resultId, feedback);
            closeModal();
        }

        // Confirmation dialogs for feedback actions
        function confirmFeedback(resultId, feedback, classification) {
            const result = analysisResults.find(r => r.id === resultId);
            if (!result) return;

            let message, actionText;
            
            if (feedback === 'correct') {
                // IT chooses to quarantine
                if (classification === 'Phishing' || classification === 'Suspicious') {
                    message = `You are choosing to QUARANTINE this email (agreeing with AI's ${classification} assessment).\n\nüõ°Ô∏è This will INDEFINITELY STORE this email in quarantine and prevent delivery to the recipient.\n\nConfirm quarantine?`;
                    actionText = "Quarantine Email";
                } else {
                    message = `You are choosing to QUARANTINE this email (overriding AI's ${classification} assessment).\n\nüõ°Ô∏è This will move the email to quarantine for security review instead of allowing delivery.\n\nConfirm quarantine?`;
                    actionText = "Quarantine Email";
                }
            } else {
                // IT chooses to send email
                if (classification === 'Phishing' || classification === 'Suspicious') {
                    message = `You are choosing to SEND this email (overriding AI's ${classification} assessment).\n\nüìß This will DELIVER this email to the intended recipient (${result.recipientEmail || 'recipient'}).\n\nAre you sure this email is safe to send?`;
                    actionText = "Send Email";
                } else {
                    message = `You are choosing to SEND this email (agreeing with AI's ${classification} assessment).\n\nüìß This email will be delivered to the recipient and marked as reviewed.\n\nConfirm sending?`;
                    actionText = "Send Email";
                }
            }

            if (confirm(message)) {
                console.log(`${actionText} confirmed for email ID: ${resultId}`);
                setFeedback(resultId, feedback);
            }
        }

        function confirmFeedbackFromModal(feedback) {
            const resultId = parseInt(document.getElementById('emailModal').dataset.resultId);
            const result = analysisResults.find(r => r.id === resultId);
            if (!result) return;

            confirmFeedback(resultId, feedback, result.classification);
        }

        // Open reasoning report modal
        function openReasoningReport(resultId) {
            const result = analysisResults.find(r => r.id === resultId);
            if (!result || !result.reasoningReport) {
                console.error('Reasoning report not found for result ID:', resultId);
                return;
            }

            const modal = document.getElementById('reasoningModal');
            const content = document.getElementById('reasoningModalContent');
            
            content.innerHTML = `
                <div class="reasoning-report-modal">
                    <div class="email-context">
                        <h3>üìß Email Context</h3>
                        <div class="context-grid">
                            <div><strong>From:</strong> ${result.sender}</div>
                            <div><strong>To:</strong> ${result.recipientEmail || 'Unknown Recipient'}</div>
                            <div><strong>Subject:</strong> ${result.subject}</div>
                            <div><strong>Classification:</strong> <span class="classification ${result.classification.toLowerCase()}">${result.classification}</span></div>
                        </div>
                        ${result.recipientInfo ? `
                            <div class="recipient-details-modal">
                                <h4>üë§ Recipient Details</h4>
                                <div class="context-grid">
                                    <div><strong>Name:</strong> ${result.recipientInfo.name}</div>
                                    <div><strong>Role:</strong> ${result.recipientInfo.role.charAt(0).toUpperCase() + result.recipientInfo.role.slice(1)}</div>
                                    <div><strong>Department:</strong> ${result.recipientInfo.department}</div>
                                    <div><strong>User Status:</strong> ${result.recipientInfo.isKnownUser ? '‚úÖ Known User' : '‚ö†Ô∏è Unknown User (Role Inferred)'}</div>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div class="reasoning-section">
                        <h4>üìã Analysis Summary</h4>
                        <p>${result.reasoningReport.summary}</p>
                    </div>
                    
                    <div class="reasoning-section">
                        <h4>‚ö†Ô∏è Threat Indicators</h4>
                        ${result.reasoningReport.threatIndicators.length > 0 ? `
                            <ul>
                                ${result.reasoningReport.threatIndicators.map(indicator => `<li>${indicator}</li>`).join('')}
                            </ul>
                        ` : '<p class="no-threats">No specific threat indicators detected.</p>'}
                    </div>
                    
                    <div class="reasoning-section">
                        <h4>üë§ Role Analysis</h4>
                        <p>${result.reasoningReport.roleAnalysis}</p>
                    </div>
                    
                    <div class="reasoning-section">
                        <h4>üîß Technical Findings</h4>
                        <ul>
                            ${result.reasoningReport.technicalFindings.map(finding => `<li>${finding}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div class="reasoning-section recommendation">
                        <h4>üí° Recommendation</h4>
                        <p><strong>${result.reasoningReport.recommendation}</strong></p>
                    </div>
                </div>
            `;
            
            modal.style.display = 'block';
        }

        // Close reasoning report modal
        function closeReasoningModal() {
            document.getElementById('reasoningModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const emailModal = document.getElementById('emailModal');
            const reasoningModal = document.getElementById('reasoningModal');
            
            if (event.target === emailModal) {
                closeModal();
            } else if (event.target === reasoningModal) {
                closeReasoningModal();
            }
        }

        // Recalculate accuracy based on actual feedback
        function recalculateAccuracy() {
            // Count total emails that have been reviewed (have feedback)
            const totalReviewed = historyResults.filter(item => item.feedback).length;
            
            // Count correct predictions
            const correctPredictions = historyResults.filter(item => item.feedback === 'correct').length;
            
            // Update metrics
            agentMemory.performanceMetrics.correctPredictions = correctPredictions;
            
            if (totalReviewed > 0) {
                agentMemory.performanceMetrics.accuracyRate = (correctPredictions / totalReviewed) * 100;
            } else {
                agentMemory.performanceMetrics.accuracyRate = 0;
            }
            
            console.log(`üìä Recalculated accuracy: ${correctPredictions}/${totalReviewed} = ${agentMemory.performanceMetrics.accuracyRate.toFixed(1)}%`);
            
            // Save updated metrics
            saveAgentMemory();
        }

        // Example email templates
        const exampleEmails = [
            {
                type: "Safe",
                sender: "hr@generalhospital.org",
                subject: "Staff Training Reminder - HIPAA Compliance",
                body: "Dear Healthcare Team, This is a reminder that our quarterly HIPAA compliance training session is scheduled for next Tuesday at 2 PM in Conference Room A. Please bring your employee ID and complete the pre-training questionnaire by Monday. Contact HR if you have any questions."
            },
            {
                type: "Suspicious",
                sender: "urgent@medical-alert.net",
                subject: "URGENT: Patient Database Maintenance Required",
                body: "We need to verify your patient database credentials immediately to prevent system lockout. Please click the link below to update your information. This is required for HIPAA compliance and system security. Failure to respond within 24 hours will result in account suspension."
            },
            {
                type: "Phishing",
                sender: "security@hospital-security.com",
                subject: "HIPAA Violation Alert - Immediate Action Required",
                body: "Your account has been flagged for HIPAA violations. Click this link immediately to avoid legal action and account suspension. Your access will be terminated in 2 hours if you don't verify your identity. This is your final warning."
            },
            {
                type: "Suspicious",
                sender: "billing@medicare-updates.org",
                subject: "Medicare Reimbursement Changes",
                body: "Important changes to Medicare billing procedures require immediate attention. Click here to download the new billing software and update your patient records. This update is mandatory for all healthcare providers to maintain compliance."
            },
            {
                type: "Safe",
                sender: "noreply@hospital.org",
                subject: "Monthly Staff Meeting Reminder",
                body: "Dear Staff, This is a reminder about our monthly staff meeting scheduled for next Friday at 2 PM in the main conference room. Please confirm your attendance by replying to this email."
            },
            {
                type: "Phishing",
                sender: "admin@healthcare-emergency.net",
                subject: "URGENT: Medical Records Compromise Detected",
                body: "We have detected unauthorized access to your medical records system. Click here immediately to secure your account and prevent data breach. Your patient information is at risk. Respond within 30 minutes or face legal consequences."
            }
        ];

        async function generateExample() {
            if (!openrouterApiKey) {
                alert('OpenRouter API key not configured. Please ensure OPENROUTER_API_KEY is set in environment variables.');
                return;
            }

            const exampleBtn = document.querySelector('.example-btn');
            const originalText = exampleBtn.innerHTML;
            
            // Show loading state
            exampleBtn.disabled = true;
            exampleBtn.innerHTML = 'üé≤ Generating...';
            
            try {
                // Generate a real-time email using AI
                const generatedEmail = await generateRealTimeEmail(openrouterApiKey);
                
                // Fill the form fields
                document.getElementById('sender').value = generatedEmail.sender;
                document.getElementById('subject').value = generatedEmail.subject;
                document.getElementById('body').value = generatedEmail.body;
                
                // Add a subtle highlight to show it was generated
                const inputs = ['sender', 'subject', 'body'];
                inputs.forEach(id => {
                    const element = document.getElementById(id);
                    element.style.backgroundColor = '#f0f9ff';
                    element.style.borderColor = '#38a169';
                    
                    // Remove highlight after 2 seconds
                    setTimeout(() => {
                        element.style.backgroundColor = '';
                        element.style.borderColor = '';
                    }, 2000);
                });
                
                console.log(`‚úÖ Generated unique email #${generationCounter}:`, generatedEmail.type, 'from', randomHospital, randomDept);
                
            } catch (error) {
                console.error('Error generating email:', error);
                // Fallback to template if AI generation fails
                const randomExample = exampleEmails[Math.floor(Math.random() * exampleEmails.length)];
                document.getElementById('sender').value = randomExample.sender;
                document.getElementById('subject').value = randomExample.subject;
                document.getElementById('body').value = randomExample.body;
            } finally {
                // Restore button state
                exampleBtn.disabled = false;
                exampleBtn.innerHTML = originalText;
            }
        }

        async function generateRealTimeEmail(apiKey) {
            const emailTypes = ['Safe', 'Suspicious', 'Phishing'];
            
            // Avoid generating the same type consecutively for more variety
            let availableTypes = emailTypes.filter(type => type !== lastGeneratedType);
            if (availableTypes.length === 0) availableTypes = emailTypes; // Fallback if all types were used
            
            const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            lastGeneratedType = randomType;
            generationCounter++;
            
            // Add randomization elements for more uniqueness
            const hospitalNames = ['General Hospital', 'Memorial Medical Center', 'City Health Clinic', 'Regional Hospital', 'Community Medical', 'University Medical Center', 'St. Mary\'s Hospital', 'Children\'s Hospital'];
            const departments = ['IT', 'HR', 'Administration', 'Security', 'Billing', 'Medical Records', 'Compliance', 'Emergency Services', 'Pharmacy', 'Laboratory'];
            const roles = ['Administrator', 'Manager', 'Director', 'Coordinator', 'Specialist', 'Supervisor', 'Officer', 'Representative'];
            const timeframes = ['immediately', 'within 24 hours', 'by end of week', 'urgently', 'as soon as possible', 'today', 'this afternoon', 'by tomorrow'];
            
            const randomHospital = hospitalNames[Math.floor(Math.random() * hospitalNames.length)];
            const randomDept = departments[Math.floor(Math.random() * departments.length)];
            const randomRole = roles[Math.floor(Math.random() * roles.length)];
            const randomTime = timeframes[Math.floor(Math.random() * timeframes.length)];
            
            // Add timestamp and random elements for uniqueness
            const timestamp = Date.now();
            const randomId = Math.random().toString(36).substring(2, 8);
            
            const prompt = `Generate a unique, realistic healthcare email that would be classified as "${randomType}". 

Context: ${randomHospital} - ${randomDept} Department
Sender Role: ${randomRole}
Urgency: ${randomTime}
Generation #${generationCounter}
Unique ID: ${randomId}
Timestamp: ${timestamp}

Requirements:
- Make it completely unique and different from typical examples
- Include specific healthcare details, terminology, and context for ${randomHospital}
- Use realistic sender domains and professional language
- For Safe: Normal hospital communications (schedules, reminders, announcements, policy updates, training notifications)
- For Suspicious: Unusual requests that might be legitimate but raise questions (access requests, data sharing, policy changes)
- For Phishing: Clear malicious intent targeting healthcare workers/patients (credential theft, fake alerts, urgent actions)

Be creative and avoid common patterns. Make each email feel like a real, unique communication.

Respond ONLY with this JSON format:
{
  "type": "${randomType}",
  "sender": "realistic.email@domain.com",
  "subject": "Unique realistic subject line",
  "body": "Detailed unique email body content"
}

Make the email detailed, believable, and completely unique.`;

            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'HTTP-Referer': window.location.origin,
                    'X-Title': 'Healthcare Email Defense Demo'
                },
                body: JSON.stringify({
                    model: 'microsoft/wizardlm-2-8x22b:free',
                    max_tokens: 300,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ]
                })
            });

            console.log('API Response status:', response.status);
            console.log('API Response headers:', response.headers);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error response:', errorText);
                throw new Error(`API request failed: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const data = await response.json();
            const content = data.choices[0].message.content;
            
            try {
                // Try to parse JSON response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    return {
                        type: result.type,
                        sender: result.sender,
                        subject: result.subject,
                        body: result.body
                    };
                } else {
                    throw new Error('No JSON found in response');
                }
            } catch (parseError) {
                console.warn('Failed to parse AI response, using fallback');
                throw new Error('Failed to parse generated email');
            }
        }

        // Initialize display
        updateResultsDisplay();
        updateHistoryDisplay();
    </script>
</body>
</html>
